// Generated by CoffeeScript 1.9.3
var clearBuffer, commands, getPromptStrings, reduceBuffer, reduceBufferedItem, reduceCharacter, reduceCommand, reduceError, reduceInputRecording, reduceKey, reduceKeyControl,
  slice = [].slice;

commands = require("../commands");

reduceKey = function(state, event) {
  var ref, updates;
  updates = null;
  if (event.type === "keydown") {
    if ((ref = event.keyCode) === 37 || ref === 39 || ref === 8 || ref === 13 || ref === 38 || ref === 40) {
      updates = reduceKeyControl(state, event);
      if (updates.command) {
        state = _.assign(state, updates);
        updates = _.assign(updates, reduceCommand(state, updates.command));
      }
    }
  } else {
    updates = reduceCharacter(state, event);
  }
  if (state.recording && updates) {
    updates = _.assign(updates, reduceInputRecording(state, event));
  }
  return updates;
};

clearBuffer = function(state) {
  var input, lines, prompt;
  lines = state.lines, input = state.input, prompt = state.prompt;
  lines.push({
    input: input,
    prompt: prompt
  });
  state = _.assign({}, state, {
    buffer: [],
    lines: lines,
    playing: false,
    recording: false,
    input: "",
    cursorPosition: 0
  });
  return state;
};

reduceError = function(state, error) {
  var buffer;
  buffer = state.buffer;
  buffer.push({
    prompt: "error >>",
    input: error.message,
    color: "red"
  });
  return _.assign({}, state, {
    buffer: buffer
  });
};

reduceBuffer = function(state) {
  var buffer, lines;
  buffer = state.buffer, lines = state.lines;
  return new Promise(function(resolve, reject) {
    var next;
    buffer = state.buffer, lines = state.lines;
    if (buffer.length > 0) {
      next = buffer.shift();
      return resolve(reduceBufferedItem(state, next));
    } else {
      return reject(new Error("Buffer is empty"));
    }
  });
};

reduceBufferedItem = function(state, bufferedItem) {
  var processError, processEvent, processLine, processPromise, processString;
  processError = function(error) {
    return new Promise(function(resolve) {
      return resolve(processString("Error: " + (error.toString())));
    });
  };
  processString = function(bufferedString) {
    return new Promise(function(resolve) {
      var input, lines, prompt, ref;
      lines = state.lines;
      input = bufferedString;
      prompt = null;
      if (input.indexOf("::") > -1) {
        ref = input.split("::"), prompt = ref[0], input = ref[1];
      }
      lines.push({
        prompt: prompt,
        input: input
      });
      return resolve({
        lines: lines
      });
    });
  };
  processPromise = function(bufferedPromise) {
    return new Promise(function(resolve) {
      return bufferedPromise.then(function(result) {
        return resolve(processBuffered(result));
      })["catch"](processError);
    });
  };
  processLine = function(bufferedLine) {
    return new Promise(function(resolve) {
      var lines;
      lines = state.lines;
      lines.push(bufferedLine);
      return resolve({
        lines: lines
      });
    });
  };
  processEvent = function(bufferedEvent) {
    return new Promise(function(resolve) {
      return _.delay(function() {
        return resolve(reduceKey(state, bufferedEvent.event));
      }, bufferedEvent.time || 0);
    });
  };
  return new Promise(function(resolve, reject) {
    var resolveState;
    resolveState = function(promise) {
      return promise.then(function(updates) {
        return resolve(_.assign({}, state, updates));
      })["catch"](function(err) {
        return reject(err);
      });
    };
    if (_.isString(bufferedItem)) {
      return resolveState(processString(bufferedItem));
    } else if (_.isFunction(bufferedItem.then)) {
      return resolveState(processPromise(bufferedItem));
    } else if (_.isObject(bufferedItem)) {
      if (bufferedItem.event) {
        return resolveState(processEvent(bufferedItem));
      } else {
        return resolveState(processLine(bufferedItem));
      }
    } else if (_.isArray(bufferedItem)) {
      return resolveState(processArray(bufferedItem));
    } else {
      return reject(new Error("Unrecognized item in buffer: ", bufferedItem));
    }
  });
};

reduceCommand = function(state, commandData) {
  var args, command, commandFunc;
  command = commandData.command, args = commandData.args;
  commandFunc = commands[command];
  if (commandFunc) {
    return commandFunc.bind(commands).apply(null, [state].concat(slice.call(args)));
  } else if (!(state.recording || state.playing)) {
    state.buffer.push({
      input: "Command \"" + command + "\" not found.",
      color: "red"
    });
    return {
      buffer: state.buffer
    };
  }
};

reduceInputRecording = function(state, event) {
  var lastEvent, ms, now, recordStartTime, recordedEvent, recordedInput;
  recordStartTime = state.recordStartTime, recordedInput = state.recordedInput;
  ms = 0;
  now = new Date();
  if (recordedInput.length > 0) {
    lastEvent = recordedInput[recordedInput.length - 1];
    ms = now - lastEvent.date;
  }
  recordedEvent = {
    type: event.type,
    keyCode: event.keyCode
  };
  recordedInput.push({
    event: recordedEvent,
    date: now,
    time: ms
  });
  return {
    recordStartTime: recordStartTime,
    recordedInput: recordedInput
  };
};

reduceCharacter = function(state, event) {
  var char, cursorPosition, input;
  input = state.input, cursorPosition = state.cursorPosition;
  char = String.fromCharCode(event.keyCode);
  input = input.substring(0, cursorPosition) + char + input.substring(cursorPosition, input.length);
  cursorPosition++;
  return {
    input: input,
    cursorPosition: cursorPosition,
    command: null
  };
};

reduceKeyControl = function(state, event) {
  var args, command, cursorPosition, history, historyScrollOffset, input, lines, parts, pos, prompt;
  input = state.input, cursorPosition = state.cursorPosition, prompt = state.prompt, history = state.history, lines = state.lines, historyScrollOffset = state.historyScrollOffset;
  command = null;
  switch (event.keyCode) {
    case 13:
      parts = input.split(" ");
      command = _.trim(parts[0].toLowerCase());
      args = parts.slice(1);
      command = {
        command: command,
        args: args
      };
      if (command.length === 0) {
        command = null;
      }
      lines.push({
        prompt: prompt,
        input: input
      });
      if (!state.playing) {
        history.push({
          prompt: prompt,
          input: input
        });
        historyScrollOffset = 0;
      }
      input = "";
      cursorPosition = 0;
      break;
    case 37:
      if (cursorPosition > 0) {
        cursorPosition = cursorPosition - 1;
      }
      break;
    case 39:
      if (cursorPosition < input.length) {
        cursorPosition = cursorPosition + 1;
      }
      break;
    case 38:
      pos = history.length + (historyScrollOffset - 1);
      if (pos > 0) {
        historyScrollOffset--;
        input = history[pos].input;
        cursorPosition = input.length;
      }
      break;
    case 40:
      pos = history.length + (historyScrollOffset + 1);
      if (pos < history.length) {
        historyScrollOffset++;
        input = history[pos].input;
        cursorPosition = input.length;
      }
      break;
    case 8:
      if (input.length <= 1) {
        input = "";
      } else {
        input = input.substring(0, cursorPosition - 1) + input.substring(cursorPosition, input.length);
        if (cursorPosition >= 1) {
          cursorPosition = cursorPosition - 1;
        } else {
          cursorPosition = 0;
        }
      }
  }
  return {
    input: input,
    cursorPosition: cursorPosition,
    history: history,
    command: command,
    historyScrollOffset: historyScrollOffset
  };
};

getPromptStrings = function(input, cursorPosition) {
  var cursor, left, right;
  left = input.substring(0, cursorPosition);
  right = input.substring(cursorPosition + 1, input.length);
  cursor = cursorPosition < input.length ? input[cursorPosition] : "\u00a0";
  return [left, cursor, right];
};

module.exports = {
  getPromptStrings: getPromptStrings,
  reduceKey: reduceKey,
  reduceBuffer: reduceBuffer,
  clearBuffer: clearBuffer,
  reduceError: reduceError
};
